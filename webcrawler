#!/usr/bin/python -u
import sys
from HTMLParser import HTMLParser
from get import get_login_page, post_login, get_first_page, get_by_url

HOSTNAME = "fring.ccs.neu.edu"
PORT = 80
RECV_MESSAGE_SIZE = 1024
#USERNAME = "001196344"
#PASSWORD = "7L3AD6ZH"
MIDDLEWARE_TOKEN = None
SESSION_ID = None
COOKIE = None

SECRET_FLAGS = []
FRONTIER = {}


class AnchorHTMLParser(HTMLParser):
    """
    This is an HTML parser for use on anchor
    tags, adding each url to the frontier (only if
    the anchor is contained on the same domain as this).
    """
    def __init__(self):
        HTMLParser.__init__(self)
        self.recording = 0
        self.data = []

    def handle_starttag(self, tag, attrs):
        global FRONTIER

        if tag == "a":
            for attr in attrs:
                if attr[0] == "href":
                    if attr[1][0].strip() == "/":
                        if attr[1] not in FRONTIER:
                            FRONTIER[attr[1]] = False


class LoginHTMLParser(HTMLParser):
    """
    This is an HTML parser for use on the Login page.
    Used to search for the csrfmiddlewaretoken needed
    for login validation.
    """
    def __init__(self):
        HTMLParser.__init__(self)
        self.recording = 0
        self.data = []

    def handle_starttag(self, tag, attrs):
        global MIDDLEWARE_TOKEN

        if tag == "input":
            for attr in attrs:
                if attr[0] == "name":
                    if attr[1] == "csrfmiddlewaretoken":
                        for attr in attrs:
                            if attr[0] == "value":
                                MIDDLEWARE_TOKEN = attr[1]


def main():
    """
    This main function is a wrapper that gets the
    username and the password as arguments from
    the command line, and attempts to login using
    those arguments. Once the user has logged in,
    the main loop starts (crawls the website)
    """
    global SESSION_ID

    username = sys.argv[1]
    password = sys.argv[2]

    while not SESSION_ID:
        login(username, password)

    main_loop()


def main_loop():
    global FRONTIER
    global COOKIE

    anchor_parser = AnchorHTMLParser()

    while len(SECRET_FLAGS) < 5:

        current_frontier = FRONTIER.copy()

        for url in current_frontier:
            if not current_frontier[url]:
                #print "Checking: " + str(url)
                response = get_by_url(url, COOKIE)

                code = find_status_code(response)
                code_range = code / 100

                response_code_actions(code_range, anchor_parser, response, url)

                if len(SECRET_FLAGS) >= 5:
                    break


        print "Checked frontier, looping again"

    anchor_parser.close()
    for flag in SECRET_FLAGS:
        print str(flag)


def response_code_actions(code_range, anchor_parser, response_str, url):
    """
    Decides what to do with the given response_str based on the status
    code range given (code_range), and the url.
    1) if 2xx, add anchor tags to the FRONTIER and look for secrets on this page
    2) if 3xx, add the redirect (location) url to the frontier if same domain
    3) if 4xx, set this url to 'searched' in the FRONTIER, no action to take
    4) if 5xx, ensure the url is set to False in the FRONTIER (try again later)
    :param code_range: Int - the status code range received in the header
    :param anchor_parser: HTMLParser - the parser class to use to parse the page
    :param response_str: String - the response from the request on the socket
    :param url: String - the url of this current page being parsed
    """
    if code_range == 2: # OK
        anchor_parser.feed(response_str)
        find_secret_flag(response_str)
        FRONTIER[url] = True

    elif code_range == 3: # REDIRECT
        print "3xx Response"
        new_url = redirect(response_str)
        if new_url:
            if new_url not in FRONTIER:
                FRONTIER[new_url] = False
        FRONTIER[url] = True

    elif code_range == 4: # NOT FOUND/ FORBIDDEN - ABANDON
        print "4xx Response"
        FRONTIER[url] = True

    elif code_range == 5: # SERVER ERROR - RETRY
        print "5xx Response"
        FRONTIER[url] = False # technically not necessary


def redirect(response):
    """
    Parses the response to find the URL contained in the
    Location header (assumes this is a redirect response)
    :param response: String - the HTTP response to parse
    :return: String (or False) - the url to redirect to
    """
    lines = response.split('\n', 1)
    for line in lines:
        if line[0:10] == "Location: ":
            url = line[10:]
            if url[0] == "/":
                return url
            host_index = url.find(HOSTNAME)
            if -1 < host_index < 10:
                url = url[host_index + len(HOSTNAME):]
            return url
    return False


def is_chunked(response):
    """
    Parses the header in the HTTP response string to determine
    if this response is chunked or not.
    :param response: String - the HTTP response to parse
    :return: Boolean - True if chunked, False if not
    """
    lines = response.split('\n', 1)
    for line in lines:
        if line.find("Transfer-Encoding: chunked"):
            return True
    return False


def find_status_code(response):
    """
    Parses the HTTP response (given) and grabs the
    status code and returns it.
    :param response: String - the HTTP response to parse
    :return: Integer - the Status code
    """
    first_line = response.split('\n', 1)[0]
    if len(first_line):
        code = first_line[9:12]
    else:
        code = 500
    return int(code)


def find_secret_flag(html_string):
    """
    Searches the given html_string for secret flags contained
    in it. If found, adds it to the global SECRET_FLAGS list.

    :param html_string: String - the html to search
    """
    global SECRET_FLAGS

    secret_flag = html_string.find("FLAG:")
    if secret_flag > -1:
        secret = html_string[secret_flag + 6: secret_flag + 70]
        if secret not in SECRET_FLAGS:
            SECRET_FLAGS.append(secret)
        print "FOUND SECRET FLAG: " + str(secret)


def login(username, password):
    """
    Performs the necessary actions to login to the fakebook website
    with the given username and password. It parses the login page
    for the unique middleware token required to login, and sets
    the cookie information needed to maintain a logged-in status.
    It then parses the initial page for any secret flags that happen
    to exist.

    :param username: String - the username to login with
    :param password: String - the password to login with
    """
    global MIDDLEWARE_TOKEN
    global SESSION_ID
    global COOKIE

    login_html = get_login_page()

    login_parser = LoginHTMLParser()

    # parse login_html for username
    login_parser.feed(login_html)
    login_parser.close()

    login_return = post_login("/accounts/login/", username, password, MIDDLEWARE_TOKEN)

    session_index = login_return.find("sessionid=")

    SESSION_ID = login_return[session_index + 10: session_index + 42]

    COOKIE = str("csrftoken=" + str(MIDDLEWARE_TOKEN) + "; sessionid=" + str(SESSION_ID))
    first_page = get_first_page(COOKIE)

    if find_status_code(first_page) / 100 != 2:
        print "Not Authorized: Incorrect Username or Password. Try again.\n"
        sys.exit(0)

    anchor_parser = AnchorHTMLParser()
    anchor_parser.feed(first_page)
    anchor_parser.close()

    find_secret_flag(first_page)

if __name__ == "__main__":
    main()
